{"posts":[{"title":"ICS 第5章 优化程序性能","text":"目录 前言 通用的编译优化 代码移动（Code Motion / Precomputation） 强度折减（Strength Reduction） 共用公共子表达式（Sharing of Common Subexpressions） 一个例子：冒泡排序 编译优化的限制（Optimization Blockers） 函数调用（Procedure Calls） 内存别名（Memory Aliasing） 小结 前言 当我们衡量一个程序的运行效率时，我们要考虑什么？ 渐进时间复杂度 常数因子 时间复杂度当然重要，但常数也必须纳入考虑。后面涉及的优化大部分都是常数优化。 通用的编译优化 代码移动（Code Motion / Precomputation） 当某个计算执行多次并产生相同结果时，只实际执行一次，减少重复计算。 常见的情况是将代码移出循环，比如课件中的例子，n*i 是在循环体之前计算的。 另外一个例子如下。 C 代码： 汇编代码（-O1）： 可以看到，编译出的汇编代码中，循环比较中的 n*m 是在循环体之前计算的。 强度折减（Strength Reduction） 把代价比较大的操作（如乘法）替换成更简单的操作。 我们可以测试编译器是否会自动进行这项优化。 C 代码： 汇编代码（-O1）： 可以看到，编译出的汇编代码中，并没有出现乘法计算，long ni = n * i 的乘法计算被加法代替了。 共用公共子表达式（Sharing of Common Subexpressions） 复用相似表达式的公共部分。在开启 -O1 及以上级别的优化时，编译器会自动完成这一优化。在课件中的例子中，通过提前计算子表达式 i*n + j，将乘法次数从 3 降到了 1。 另外一个例子如下。 C 代码： 汇编代码（-O1）： 可以看到，n*i 作为公共子表达式被复用了。 一个例子：冒泡排序 以冒泡排序为例，我们可以分析它的优化过程。 这是冒泡排序的 C 代码以及它所对应的细化后的伪代码。 可以看到，在地址计算中，存在着很多冗余（Redundancy）。 t5 的计算完全是多余的：执行完 t4 := j+1 和 t5 := t4-1 后，t5 就等于 j；t11 同理。t15 的计算过程与 t9 完全相同，也是多余的；t18 同理。 初步去除冗余后，我们可以得到下面的伪代码。 我们还可以观察到更多的冗余。 A[j] 和 A[j+1] 的值在之前进行大小比较时已经取出，不必再取一次。 再次去除冗余后，我们可以得到下面的伪代码。 循环过程中仍然存在冗余。 直接把循环变量的步长改为 4，可以去除大部分的乘法操作。 修改后的伪代码如下。 最终的伪代码如下。可以看到，内外层每轮循环的指令数都大幅度下降，运行效率从而大幅度提高。我们可以用伪代码的优化过程类比编译器在编译中的优化过程。 这些优化都可以在伪代码层面体现出来，是不依赖机器（Machine Independent）的。 编译优化的限制（Optimization Blockers） 编译优化不能改变程序行为。 当然，前提是程序符合语言标准。编译优化可能改变未定义行为（Undefined Behavior, UB）的运行结果，如有符号整数溢出、数组越界访问、访问未初始化变量、(x++ * ++x)等。 当编译器无法保证优化不会改变程序行为时，编译器会采取保守策略，往往就是不进行相应的优化。 以下是两种常见的限制编译优化的因素，函数调用（Procedure Calls）和内存别名（Memory Aliasing）。 函数调用（Procedure Calls） 以下代码将字符串 s 中的所有大写字母转成小写字母。 1234567// 优化前void lower(char *s) { size_t i; for(i = 0; i &lt; strlen(s); i++) if(s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') s[i] -= ('A' - 'a');} 在实际的测试中，它的运行效率非常缓慢——在每轮循环中，都会调用 strlen 函数，这个函数的工作方式是向后遍历整个字符串，直到找到 \\0 字符。 这导致它的时间复杂度变为 O(n2)O(n^2)O(n2)，而原本在 O(n)O(n)O(n) 的时间里即可完成这一任务，只要简单地把 strlen(s) 提前计算好。 12345678// 优化后void lower(char *s) { size_t i; size_t len = strlen(s); for(i = 0; i &lt; len; i++) if(s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') s[i] -= ('A' - 'a');} 这里我们其实就是手动完成了之前所说的 Code Motion。因为调用了函数 strlen，所以编译器不会自动完成这项优化。 函数可能会有副作用（改变某些全局状态），也可能在参数相同的不同调用中返回不同的结果（依赖于某些全局状态等）。 因此，编译器把函数调用视为黑箱。涉及函数调用时，编译器能进行的优化非常有限。 但我们可以用内联函数替换（Inline Substitution）的方式进行优化，将函数调用替换为函数体。 比如，在下面的代码中，func1 调用了 f。 1234567long cnt = 0;long f() { return cnt++;}long func1() { return f() + f() + f() + f();} 内联函数替换后得到的结果如下。 1234567long func1in() { long t = cnt++; t += cnt++; t += cnt++; t += cnt++; return t;} 对 func1in，编译器就可以进行优化了。 12345long func1opt() { long t = 4 * cnt + 6; cnt += 4; return t;} GCC 的最近版本会尝试进行这种形式的优化（使用命令行选项 -finline 或 开启 -O1 及以上级别的优化时）。 不过，GCC 只尝试在单个文件中定义的函数的内联，不进行跨文件的内联。 内存别名（Memory Aliasing） 下面的函数对 n×n 矩阵 a 的每一行求和并依次存储到 b 中。（是这样吗？） 12345678void sum_rows1(double *a, double *b, long n) { long i, j; for(i = 0; i &lt; n; i++) { b[i] = 0; for(j = 0; j &lt; n; j++) b[i] += a[i*n + j]; }} 编译出的汇编代码如下。 12345678# sum_rows1 inner loop.L4: movsd (%rsi,%rax,8), %xmm0 # FP load addsd (%rdi), %xmm0 # FP add movsd %xmm0, (%rsi,%rax,8) # FP store addq $8, %rdi cmpq %rcx, %rdi jne .L4 为什么编译器不使用一个浮点寄存器暂存 b[i]，来减少内存加载的次数呢？ 实际上，a 和 b 的某些部分可能是重合的（这被称为内存别名，即两个不同的内存引用指定了同一个内存位置），如上所述的优化可能改变运行结果，所以编译器不会进行这一优化。 我们可以手动优化。 123456789void sum_rows2(double *a, double *b, long n) { long i, j; for(i = 0; i &lt; n; i++) { double val = 0; for(j = 0; j &lt; n; j++) val += a[i*n + j]; b[i] = val; }} 编译出的汇编代码如下。 123456# sum_rows2 inner loop.L10: addsd (%rdi), %xmm0 # FP load + add addq $8, %rdi cmpq %rax, %rdi jne .L10 我们在编写 C 语言代码的时候知道（或者说，会在调用 sum_rows2 时保证），数组 a 与 b 在内存中没有重叠部分，所以进行这一优化不会影响程序行为。编译器不知道这一点。 所以，在写代码时要记得引入局部变量，这其实是在告诉编译器不用考虑 Memory Aliasing。 小结 通用的编译优化 代码移动（Code Motion / Precomputation） 强度折减（Strength Reduction） 共用公共子表达式（Sharing of Common Subexpressions） 一个例子：冒泡排序 编译优化的限制（Optimization Blockers） 函数调用（Procedure Calls） 内存别名（Memory Aliasing） When in doubt, the compiler must be conservative.","link":"/2025/11/23/ICS-%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/"},{"title":"ICS 第9章 虚拟内存","text":"怎么又要回课了。 此坑待填","link":"/2025/11/23/ICS-%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"},{"title":"ICS 阶段测验1 部分题目解析","text":"是谁上了大学还要月考啊😡 15. x86-64 中，执行 popq %rbx 的操作依次为如下步骤： (1) 从寄存器 %rsp 中读出数据 x，以 x 为地址，读出对应内存中的数据 y； (2) 将 (1) 中提到的寄存器（加减多少）： 加 8 ； (3) 将 y 存到寄存器 %rbx 中。 解析：pushq 和 popq 可以将数据压入程序栈中，以及从程序栈中弹出数据。栈向下增长，即栈顶元素的地址最低。栈指针 %rsp 保存着栈顶元素的地址。 指令 效果 描述 pushq S R[%rsp]←R[%rsp]-8;M[R[%rsp]]←S 将四字压入栈 popq D D←M[R[%rsp]];R[%rsp]←R[%rsp]+8 将四字弹出栈 16. 以下两组对应的 C 语言代码和汇编语言代码: 1234void multstore(long x, long y, long *dest) { long t = mult2(x, y); *dest = t;} 12345670000000000400640 &lt;multstore&gt;: 400640: push %rbx 400641: mov %rdx, %rbx 400644: callq 400650 &lt;mult2&gt; 400649: mov %rax, (%rbx) 40064c: pop %rbx 40064d: retq 1234long mult2(long a, long b) { long s = a * b; return s;} 12340000000000400650 &lt;mult2&gt;: 400650: mov %rdi, %rax 400653: imul %rsi, %rax 400657: retq (1) 假设准备执行 callq 指令时，%rsp 内容为 0x110，那执行完 callq 指令后， %rsp 内容为 0x108 ，%rsp 指向的内存中的数值为 0x400649 。随后执行完地址 400657 处的 retq 指令后，%rsp 内容为 0x110 。（均为十六进制） 解析：在 x86-64 机器中，指令 call Q 会把地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。压入的地址 A 被称为返回地址，是紧跟在 call 指令后面的那条指令的地址。对应的指令ret 会从栈中弹出地址 A，并把 PC 设置为 A。 (2) C 代码中的下列变量分别保存在哪个寄存器中： 变量 寄存器 x %rdi y %rsi a %rdi b %rsi s %rax 解析：multstore 中，x 为第一个参数，y 为第二个参数，分别存放在 %rdi 和 %rsi 中。 mult2 中，a 为第一个参数，b 为第二个参数，s 为返回值，分别存放在 %rdi、%rsi 和 %rax 中。 (3) 汇编代码中，地址 400641 的指令修改了 %rbx，地址 400649 的指令使用了 %rbx，而二者中间有过程调用 call，是什么机制保证了 %rbx 不会被修改： 答案：根据惯例，寄存器 %rbx、%rbp 和 %r12~%r15 被划分为被调用者保存寄存器。当过程 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的（要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值）。压入寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分。有了这条惯例，P 的代码就能安全地把值存在被调用者保存寄存器中（当然，要先把之前的值保存到栈上），调用 Q，然后继续使用寄存器中的值，不用担心值被破坏。 (4) 如果把 C 代码中的 mult2(x,y) 改为 mult2(y,x)，汇编代码会有什么变化： 答案：在执行 callq 指令之前，先交换 %rdi 和 %rsi 的值。下面这段汇编代码可以实现这一功能。 123mov %rdi, %raxmov %rsi, %rdimov %rax, %rsi 17. 考虑以下 C 语言代码: 12345678910111213141516long bit_not1(long a) { long x = ~p; return x;}long bit_not2(long *p) { long x = *p; long y = ~x; return y;}long call_bitnot() { long v0 = 1010; long v1 = 1010; long v2 = bit_not1(v0); long v3 = bit_not2(&amp;v1); return v2 + v3;} 下列变量分别存放在寄存器还是内存中? 变量 存放位置 v0 寄存器 v1 内存 v2 寄存器 v3 寄存器 解析：局部数据默认存放在寄存器中，不过有些时候，局部数据必须存放在内存中，常见的情况包括∶ 寄存器不足够存放所有的本地数据。 对一个局部变量使用地址运算符 &amp;，因此必须能够为它产生一个地址。 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。 由于代码中出现了 &amp;v1，所以 v1 必须存放在内存中，而 v0、v2 和 v3 则存放在寄存器中。 不过话又说回来，这阶段测验 1 确实不难。","link":"/2025/11/23/ICS-%E9%98%B6%E6%AE%B5%E6%B5%8B%E9%AA%8C1-%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/"},{"title":"关于这个博客","text":"随缘更，说不定以后会写点东西呢。","link":"/2025/11/22/%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"title":"暑期DLC记忆","text":"本篇待施工 暑期 DLC【10&amp;15】 兰州-大河家-扎巴-雄先-倒淌河-江西沟-茶卡-刚察-多巴 暑期结束于兰州。 我在自述中说，有一天我一定会去骑一次环青海湖。而兰州离青海湖只有 300 余千米，机会就在眼前。刚好小弟也想在暑期后多骑一段，于是暑期 DLC 就这样诞生了。 由于我和小弟都认为我俩的体能比较好，出发前我们的路线定得相当激进：日均 150km+ 爬升 2000m+。事实上，我们还是高估了自己（尤其是恢复能力），到最后，我们没有几天是把原定路线骑完的。 Day 1 兰州-大河家镇 DLC 的开头并非顺利。从兰州出发时就开始下起小雨，在中午之前雨几乎没有真正停下过。出兰州市区就是一个 20km 爬升 1000m 的 HC，那个坡很长，坡顶很冷，两人在坡顶瑟瑟发抖，幸好找到了一家小卖部，在小卖部里用吹风机把衣服吹干才继续放坡。 在放坡结束后的小镇吃了午饭。从午饭点出来的时候发现我扎了 下午是先爬一个比较长的坡，然后走起伏路。起伏路云雾缭绕，在云间骑车也未尝不是一种独特的体验。 天色渐暗。拐个弯走上一条县道，然后我们见到了非常离谱的烂路，前面的面包车都因为开不过去折返了，而我们没有其他可选的距离合适的路线，于是被迫推车过去，推完之后我的车变成了下图中的样子。 然后是一段烂路放坡。 夜幕逐渐笼罩四周。两人骑行在空旷的道路上，左手边就是黄河。 终于还是在 9 点前到了——不过是把目的地改近了一点。 ​Day 2 大河家镇-扎巴镇 ​Day 3 扎巴镇-雄先乡 Day 4 雄先乡-倒淌河镇 Day 5 倒淌河镇-江西沟镇 Day 6 江西沟镇-茶卡镇 Day 7 ​茶卡镇休整 Day 8 茶卡镇-刚察县 Day 9 刚察县-多巴镇 结算画面","link":"/2025/11/23/%E6%9A%91%E6%9C%9FDLC%E8%AE%B0%E5%BF%86/"},{"title":"关于我","text":"暂时不能给你明确的答复 我是 lowAltitudeFlyer（低空飞行），来自北京大学信息科学技术学院智班。 我喜欢跑步、骑车和美食。","link":"/2025/11/22/%E5%85%B3%E4%BA%8E%E6%88%91/"},{"title":"VCL复习笔记","text":"明天 VCL 小测，现在要开始复习预习了。 05 反走样 Nyquist-Shannon 采样定理 为了完全避免走样的发生，我们需要让采样频率 fsf_sfs​ 至少是原信号截止频率 f0f_0f0​ 的两倍。 07 图像表示与处理 Bayesian 抠图 Poisson 抠图 08 几何表示 09 几何处理 10 几何变换 11 几何重建 12 光照和着色 反射模型 漫反射Ld=kd(Ia+Idmax⁡(0,n⋅l))L_d = k_d(I_a+I_d\\max(0,\\mathbf{n}\\cdot\\mathbf{l})) Ld​=kd​(Ia​+Id​max(0,n⋅l)) 其中 kdk_dkd​ 是表面的漫反射颜色，n\\mathbf{n}n 是表面法向，l\\mathbf{l}l 是光源的方向（从入射点指向光源），IaI_aIa​ 是环境光强度，IdI_dId​ 是光源强度（对于点光源，Id=Ipr2I_d=\\frac{I_p}{r^2}Id​=r2Ip​​）。 镜面反射Ls=ksIdmax⁡(0,n⋅h)pL_s = k_sI_d\\max(0,\\mathbf{n}\\cdot\\mathbf{h})^p Ls​=ks​Id​max(0,n⋅h)p 其中 ksk_sks​ 是表面的镜面反射颜色，n\\mathbf{n}n 是表面法向，h=normalize(l+v)\\mathbf{h}=\\text{normalize}(\\mathbf{l}+\\mathbf{v})h=normalize(l+v)（v\\mathbf{v}v 是观察者的方向），IdI_dId​ 是光源强度。 Blinn-Phong 反射模型 对于一般的物体，我们可以认为同时存在漫反射和镜面反射，从而有L=kd(Ia+Idmax⁡(0,n⋅l))+ksIdmax⁡(0,n⋅h)pL = k_d(I_a+I_d\\max(0,\\mathbf{n}\\cdot\\mathbf{l}))+k_sI_d\\max(0,\\mathbf{n}\\cdot\\mathbf{h})^p L=kd​(Ia​+Id​max(0,n⋅l))+ks​Id​max(0,n⋅h)p 13 图形管线 14 纹理映射 15 全局光照 16 高级渲染 17 物理模拟 弹簧-质点系统 两质点间的弹性势能为 Eij=12kij(∥xj−xi∥−lij)2E_{ij} = \\frac{1}{2} k_{ij} (\\left\\| \\mathbf{x}_j − \\mathbf{x}_i \\right\\| − l_{ij})^2Eij​=21​kij​(∥xj​−xi​∥−lij​)2 该弹簧的弹力为 fij=kij(∥xj−xi∥−lij)nijf_{ij} = k_{ij} (\\left\\| \\mathbf{x}_j − \\mathbf{x}_i \\right\\| − l_{ij}) \\mathbf{n}_{ij} fij​=kij​(∥xj​−xi​∥−lij​)nij​ 其中 nij\\mathbf{n}_{ij}nij​ 为从质点 iii 指向质点 jjj 方向的单位向量。 显式欧拉法 \\mathbf{x}^{k+1} = \\mathbf{x}^k + h\\mathbf{v}^k$$ $$\\mathbf{v}^{k+1} = \\mathbf{v}^k + h\\mathbf{M}^{-1}\\mathbf{f}(\\mathbf{x}^k) 隐式欧拉法 \\mathbf{x}^{k+1} = \\mathbf{x}^k + h\\mathbf{v}^{k+1}$$ $$\\mathbf{v}^{k+1} = \\mathbf{v}^k + h\\mathbf{M}^{-1}\\mathbf{f}(\\mathbf{x}^{k+1}) NS 方程 ρDvDt=−∇p+ρg+μ∇2v\\rho \\frac{\\mathrm{D}\\mathbf{v}}{\\mathrm{D}t} = -\\nabla p + \\rho \\mathbf{g} + \\mu \\nabla^2 \\mathbf{v} ρDtDv​=−∇p+ρg+μ∇2v","link":"/2025/11/24/VCL%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"回课","slug":"回课","link":"/tags/%E5%9B%9E%E8%AF%BE/"},{"name":"阶段测验","slug":"阶段测验","link":"/tags/%E9%98%B6%E6%AE%B5%E6%B5%8B%E9%AA%8C/"},{"name":"qwq","slug":"qwq","link":"/tags/qwq/"},{"name":"长途","slug":"长途","link":"/tags/%E9%95%BF%E9%80%94/"},{"name":"夏","slug":"夏","link":"/tags/%E5%A4%8F/"},{"name":"青海湖","slug":"青海湖","link":"/tags/%E9%9D%92%E6%B5%B7%E6%B9%96/"}],"categories":[{"name":"ICS","slug":"ICS","link":"/categories/ICS/"},{"name":"最初的最初","slug":"最初的最初","link":"/categories/%E6%9C%80%E5%88%9D%E7%9A%84%E6%9C%80%E5%88%9D/"},{"name":"骑行","slug":"骑行","link":"/categories/%E9%AA%91%E8%A1%8C/"},{"name":"VCL","slug":"VCL","link":"/categories/VCL/"}],"pages":[]}