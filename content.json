{"posts":[{"title":"ICS 第9章 虚拟内存","text":"怎么又要回课了。 前言 为什么我们需要虚拟内存？ 虚拟内存（Virtual Memory，VM）为每个进程提供了一个大的、一致的和私有的地址空间。 大：323232 位地址可以表示 232=4G2^{32}=4\\mathrm{G}232=4G 个字节，646464 位地址可以表示 264=16384P2^{64}=16384\\mathrm{P}264=16384P 个字节。按照当前主流的 32GB32\\mathrm{GB}32GB 的内存条算，需要插 229=512M2^{29}=512\\mathrm{M}229=512M 根内存条才能满足 646464 位地址的最大寻址空间，这显然是无法承受的。 一致：无论物理内存的实际布局如何（可能非常碎片化），每个进程都认为自己拥有一个连续的线性地址空间。 私有：一个进程无法读写另一个进程的私有内存数据，从而防止了进程间的相互干扰，实现了地址空间的隔离和保护。 物理寻址和虚拟寻址 物理寻址 主存被组织成一个由 MMM 个连续的字节单元组成的数组，每个字节都有一个唯一的物理地址（Physical Address，PA）。 CPU 访问内存的最自然的方式就是使用物理地址，这种方式被称为物理寻址。 早期的 PC 使用物理寻址，而且数字信号处理器、嵌入式微控制器（在汽车、电梯和数码相框等设备中使用）以及 Cray 超级计算机这样的系统仍在继续使用物理寻址。 虚拟寻址 CPU 通过生成一个虚拟地址（Virtual Address，VA）来访问主存，在访存时先把这个虚拟地址转换成适当的物理地址，即地址翻译。 CPU 上的内存管理单元（Memory Management Unit，MMU）利用存放在主存中的页表来动态翻译虚拟地址，该表的内容由操作系统管理。 * ARM 体系结构的主要产品线 产品线 虚拟存储 主要应用场景 “应用”配置：Cortex-A 系列 支持 高性能计算、通用操作系统：智能手机、平板电脑、服务器、车载信息娱乐系统（IVI）、高级辅助驾驶系统（ADAS）等 “嵌入式”配置：Cortex-R 系列 不一定 实时、安全关键系统：汽车动力系统、制动系统、工业控制、硬盘控制器等 “微处理器”配置：Cortex-M 系列 不支持 微控制器、深度嵌入式设备：物联网（IoT）、传感器、简单控制、基础外设管理等 地址空间 地址空间是一个非负整数地址的有序集合。我们总是假设使用的是线性地址空间，即地址空间中的整数连续。 CPU 从一个有 N=2nN=2^nN=2n 个地址的虚拟地址空间中生成虚拟地址： {0,1,2,…,N−1}\\{0,1,2,\\dots,N-1\\} {0,1,2,…,N−1} nnn 位地址空间即包含 2n2^n2n 个地址的虚拟空间。 物理地址空间对应于物理内存的 MMM 个字节： {0,1,2,…,M−1}\\{0,1,2,\\dots,M-1\\} {0,1,2,…,M−1} MMM 不要求是 222 的幂，但为了简化讨论，我们假设 M=2mM=2^mM=2m。 虚拟内存作为缓存的工具 虚拟页和物理页 VM 系统将虚拟内存分割为大小固定的块，称为虚拟页（Virtual Page，VP），每个虚拟页的大小为 P=2pP=2^pP=2p 字节。 类似地，物理内存被分割为物理页（Physical Page，PP），大小也为 PPP 字节。 在任意时刻，虚拟页的集合都被分为三个不相交的子集： 未分配的（Unallocated）：VM 系统还未分配（创建）的页，不占用任何磁盘空间。 缓存的（Cached）：当前已缓存在物理内存中的已分配页。 未缓存的（Uncached）：未缓存在物理内存中的已分配页。 页表 VM 系统必须有某种方法来判定一个虚拟页是否缓存在主存中的某个地方。如果是，VM 系统还必须确定这个虚拟页存放在哪个物理页中。如果否，VM 系统必须确定这个虚拟页存放在磁盘的哪个位置，并在物理内存中选择一个页替换。 操作系统软件、MMU 中的地址翻译硬件和存放在物理内存中的页表共同实现这一功能。页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘和物理内存之间来回传送页。 页表是一个页表条目（Page Table Entry，PTE）的数组。每个 PTE 由一个有效位和一个 nnn 位地址字段组成。有效位表明了该虚拟页是否被缓存在物理内存中： 如果设置了有效位，那么地址字段就表示物理内存中相应物理页的起始位置。 如果没有设置有效位： 如果虚拟页还未分配，那么地址字段为一个空地址。 如果虚拟页已分配，那么地址字段就指向该虚拟页在磁盘上的起始位置。 页命中 CPU 尝试访问虚拟内存中的一个已缓存在物理内存中的字。它使用 PTE 中的物理内存地址，构造出这个字的物理地址。这种情况被称为页命中（Page Hit）。 缺页 CPU 尝试访问虚拟内存中的一个未缓存在物理内存中的字。这种情况被称为缺页（Page Fault）。地址翻译硬件检测到缺页，触发一个缺页异常。 缺页异常调用内核中的缺页异常处理程序，该程序会选择一个物理内存中的牺牲页（如果牺牲页已经被修改了，那么内核会先将它复制回磁盘），修改牺牲页的 PTE，并将要访问的虚拟页从磁盘复制到物理内存，更新要访问的虚拟页的 PTE。当异常处理程序返回时，它会重新启动导致缺页的指令，此时该指令就会得到一个页命中。 一直等待，直到不命中发生，才把页面换入虚拟内存，这种策略被称为按需页面调度（Demand Paging）。这种 Lazy 的策略在计算机中被广泛使用。 新分配页 当操作系统分配一个新的虚拟内存页时，在磁盘上创建空间并更新对应的 PTE。随后要访问这个虚拟内存页时，会触发一个缺页异常，从而把它缓存到物理内存。 虚拟内存中的局部性 VM 系统看起来效率很低，但因为局部性的存在，虚拟内存实际上工作得相当好。 局部性原则保证，在任意时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合叫做工作集或常驻集合。在初始开销（冷不命中）之后，对这个工作集的引用将导致命中，不会产生额外的磁盘访问。 只要我们的程序有好的时间局部性，VM 系统就能工作得相当好。但如果工作集的大小超出了物理内存的大小，就会产生抖动，此时页面将不断地换进换出，严重影响效率。","link":"/2025/11/23/ICS-%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"},{"title":"ICS 第5章 优化程序性能","text":"qwq 目录 前言 通用的编译优化 代码移动（Code Motion / Precomputation） 强度折减（Strength Reduction） 共用公共子表达式（Sharing of Common Subexpressions） 一个例子：冒泡排序 编译优化的限制（Optimization Blockers） 函数调用（Procedure Calls） 内存别名（Memory Aliasing） 小结 前言 当我们衡量一个程序的运行效率时，我们要考虑什么？ 渐进时间复杂度 常数因子 时间复杂度当然重要，但常数也必须纳入考虑。后面涉及的优化大部分都是常数优化。 通用的编译优化 代码移动（Code Motion / Precomputation） 当某个计算执行多次并产生相同结果时，只实际执行一次，减少重复计算。 常见的情况是将代码移出循环，比如课件中的例子，n*i 是在循环体之前计算的。 另外一个例子如下。 C 代码： 汇编代码（-O1）： 可以看到，编译出的汇编代码中，循环比较中的 n*m 是在循环体之前计算的。 强度折减（Strength Reduction） 把代价比较大的操作（如乘法）替换成更简单的操作。 我们可以测试编译器是否会自动进行这项优化。 C 代码： 汇编代码（-O1）： 可以看到，编译出的汇编代码中，并没有出现乘法计算，long ni = n * i 的乘法计算被加法代替了。 共用公共子表达式（Sharing of Common Subexpressions） 复用相似表达式的公共部分。在开启 -O1 及以上级别的优化时，编译器会自动完成这一优化。在课件中的例子中，通过提前计算子表达式 i*n + j，将乘法次数从 3 降到了 1。 另外一个例子如下。 C 代码： 汇编代码（-O1）： 可以看到，n*i 作为公共子表达式被复用了。 一个例子：冒泡排序 以冒泡排序为例，我们可以分析它的优化过程。 这是冒泡排序的 C 代码以及它所对应的细化后的伪代码。 可以看到，在地址计算中，存在着很多冗余（Redundancy）。 t5 的计算完全是多余的：执行完 t4 := j+1 和 t5 := t4-1 后，t5 就等于 j；t11 同理。t15 的计算过程与 t9 完全相同，也是多余的；t18 同理。 初步去除冗余后，我们可以得到下面的伪代码。 我们还可以观察到更多的冗余。 A[j] 和 A[j+1] 的值在之前进行大小比较时已经取出，不必再取一次。 再次去除冗余后，我们可以得到下面的伪代码。 循环过程中仍然存在冗余。 直接把循环变量的步长改为 4，可以去除大部分的乘法操作。 修改后的伪代码如下。 最终的伪代码如下。可以看到，内外层每轮循环的指令数都大幅度下降，运行效率从而大幅度提高。我们可以用伪代码的优化过程类比编译器在编译中的优化过程。 这些优化都可以在伪代码层面体现出来，是不依赖机器（Machine Independent）的。 编译优化的限制（Optimization Blockers） 编译优化不能改变程序行为。 当然，前提是程序符合语言标准。编译优化可能改变未定义行为（Undefined Behavior, UB）的运行结果，如有符号整数溢出、数组越界访问、访问未初始化变量、(x++ * ++x)等。 当编译器无法保证优化不会改变程序行为时，编译器会采取保守策略，往往就是不进行相应的优化。 以下是两种常见的限制编译优化的因素，函数调用（Procedure Calls）和内存别名（Memory Aliasing）。 函数调用（Procedure Calls） 以下代码将字符串 s 中的所有大写字母转成小写字母。 1234567// 优化前void lower(char *s) { size_t i; for(i = 0; i &lt; strlen(s); i++) if(s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') s[i] -= ('A' - 'a');} 在实际的测试中，它的运行效率非常缓慢——在每轮循环中，都会调用 strlen 函数，这个函数的工作方式是向后遍历整个字符串，直到找到 \\0 字符。 这导致它的时间复杂度变为 O(n2)O(n^2)O(n2)，而原本在 O(n)O(n)O(n) 的时间里即可完成这一任务，只要简单地把 strlen(s) 提前计算好。 12345678// 优化后void lower(char *s) { size_t i; size_t len = strlen(s); for(i = 0; i &lt; len; i++) if(s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') s[i] -= ('A' - 'a');} 这里我们其实就是手动完成了之前所说的 Code Motion。因为调用了函数 strlen，所以编译器不会自动完成这项优化。 函数可能会有副作用（改变某些全局状态），也可能在参数相同的不同调用中返回不同的结果（依赖于某些全局状态等）。 因此，编译器把函数调用视为黑箱。涉及函数调用时，编译器能进行的优化非常有限。 但我们可以用内联函数替换（Inline Substitution）的方式进行优化，将函数调用替换为函数体。 比如，在下面的代码中，func1 调用了 f。 1234567long cnt = 0;long f() { return cnt++;}long func1() { return f() + f() + f() + f();} 内联函数替换后得到的结果如下。 1234567long func1in() { long t = cnt++; t += cnt++; t += cnt++; t += cnt++; return t;} 对 func1in，编译器就可以进行优化了。 12345long func1opt() { long t = 4 * cnt + 6; cnt += 4; return t;} GCC 的最近版本会尝试进行这种形式的优化（使用命令行选项 -finline 或 开启 -O1 及以上级别的优化时）。 不过，GCC 只尝试在单个文件中定义的函数的内联，不进行跨文件的内联。 内存别名（Memory Aliasing） 下面的函数对 n×n 矩阵 a 的每一行求和并依次存储到 b 中。（是这样吗？） 12345678void sum_rows1(double *a, double *b, long n) { long i, j; for(i = 0; i &lt; n; i++) { b[i] = 0; for(j = 0; j &lt; n; j++) b[i] += a[i*n + j]; }} 编译出的汇编代码如下。 12345678# sum_rows1 inner loop.L4: movsd (%rsi,%rax,8), %xmm0 # FP load addsd (%rdi), %xmm0 # FP add movsd %xmm0, (%rsi,%rax,8) # FP store addq $8, %rdi cmpq %rcx, %rdi jne .L4 为什么编译器不使用一个浮点寄存器暂存 b[i]，来减少内存加载的次数呢？ 实际上，a 和 b 的某些部分可能是重合的（这被称为内存别名，即两个不同的内存引用指定了同一个内存位置），如上所述的优化可能改变运行结果，所以编译器不会进行这一优化。 我们可以手动优化。 123456789void sum_rows2(double *a, double *b, long n) { long i, j; for(i = 0; i &lt; n; i++) { double val = 0; for(j = 0; j &lt; n; j++) val += a[i*n + j]; b[i] = val; }} 编译出的汇编代码如下。 123456# sum_rows2 inner loop.L10: addsd (%rdi), %xmm0 # FP load + add addq $8, %rdi cmpq %rax, %rdi jne .L10 我们在编写 C 语言代码的时候知道（或者说，会在调用 sum_rows2 时保证），数组 a 与 b 在内存中没有重叠部分，所以进行这一优化不会影响程序行为。编译器不知道这一点。 所以，在写代码时要记得引入局部变量，这其实是在告诉编译器不用考虑 Memory Aliasing。 小结 通用的编译优化 代码移动（Code Motion / Precomputation） 强度折减（Strength Reduction） 共用公共子表达式（Sharing of Common Subexpressions） 一个例子：冒泡排序 编译优化的限制（Optimization Blockers） 函数调用（Procedure Calls） 内存别名（Memory Aliasing） When in doubt, the compiler must be conservative.","link":"/2025/11/23/ICS-%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/"},{"title":"ICS 阶段测验1 部分题目解析","text":"是谁上了大学还要月考啊😡 15. x86-64 中，执行 popq %rbx 的操作依次为如下步骤： (1) 从寄存器 %rsp 中读出数据 x，以 x 为地址，读出对应内存中的数据 y； (2) 将 (1) 中提到的寄存器（加减多少）： 加 8 ； (3) 将 y 存到寄存器 %rbx 中。 解析：pushq 和 popq 可以将数据压入程序栈中，以及从程序栈中弹出数据。栈向下增长，即栈顶元素的地址最低。栈指针 %rsp 保存着栈顶元素的地址。 指令 效果 描述 pushq S R[%rsp]←R[%rsp]-8;M[R[%rsp]]←S 将四字压入栈 popq D D←M[R[%rsp]];R[%rsp]←R[%rsp]+8 将四字弹出栈 16. 以下两组对应的 C 语言代码和汇编语言代码: 1234void multstore(long x, long y, long *dest) { long t = mult2(x, y); *dest = t;} 12345670000000000400640 &lt;multstore&gt;: 400640: push %rbx 400641: mov %rdx, %rbx 400644: callq 400650 &lt;mult2&gt; 400649: mov %rax, (%rbx) 40064c: pop %rbx 40064d: retq 1234long mult2(long a, long b) { long s = a * b; return s;} 12340000000000400650 &lt;mult2&gt;: 400650: mov %rdi, %rax 400653: imul %rsi, %rax 400657: retq (1) 假设准备执行 callq 指令时，%rsp 内容为 0x110，那执行完 callq 指令后， %rsp 内容为 0x108 ，%rsp 指向的内存中的数值为 0x400649 。随后执行完地址 400657 处的 retq 指令后，%rsp 内容为 0x110 。（均为十六进制） 解析：在 x86-64 机器中，指令 call Q 会把地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。压入的地址 A 被称为返回地址，是紧跟在 call 指令后面的那条指令的地址。对应的指令ret 会从栈中弹出地址 A，并把 PC 设置为 A。 (2) C 代码中的下列变量分别保存在哪个寄存器中： 变量 寄存器 x %rdi y %rsi a %rdi b %rsi s %rax 解析：multstore 中，x 为第一个参数，y 为第二个参数，分别存放在 %rdi 和 %rsi 中。 mult2 中，a 为第一个参数，b 为第二个参数，s 为返回值，分别存放在 %rdi、%rsi 和 %rax 中。 (3) 汇编代码中，地址 400641 的指令修改了 %rbx，地址 400649 的指令使用了 %rbx，而二者中间有过程调用 call，是什么机制保证了 %rbx 不会被修改： 答案：根据惯例，寄存器 %rbx、%rbp 和 %r12~%r15 被划分为被调用者保存寄存器。当过程 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的（要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值）。压入寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分。有了这条惯例，P 的代码就能安全地把值存在被调用者保存寄存器中（当然，要先把之前的值保存到栈上），调用 Q，然后继续使用寄存器中的值，不用担心值被破坏。 (4) 如果把 C 代码中的 mult2(x,y) 改为 mult2(y,x)，汇编代码会有什么变化： 答案：在执行 callq 指令之前，先交换 %rdi 和 %rsi 的值。下面这段汇编代码可以实现这一功能。 123mov %rdi, %raxmov %rsi, %rdimov %rax, %rsi 17. 考虑以下 C 语言代码: 12345678910111213141516long bit_not1(long a) { long x = ~p; return x;}long bit_not2(long *p) { long x = *p; long y = ~x; return y;}long call_bitnot() { long v0 = 1010; long v1 = 1010; long v2 = bit_not1(v0); long v3 = bit_not2(&amp;v1); return v2 + v3;} 下列变量分别存放在寄存器还是内存中? 变量 存放位置 v0 寄存器 v1 内存 v2 寄存器 v3 寄存器 解析：局部数据默认存放在寄存器中，不过有些时候，局部数据必须存放在内存中，常见的情况包括∶ 寄存器不足够存放所有的本地数据。 对一个局部变量使用地址运算符 &amp;，因此必须能够为它产生一个地址。 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。 由于代码中出现了 &amp;v1，所以 v1 必须存放在内存中，而 v0、v2 和 v3 则存放在寄存器中。 不过话又说回来，这阶段测验 1 确实不难。","link":"/2025/11/23/ICS-%E9%98%B6%E6%AE%B5%E6%B5%8B%E9%AA%8C1-%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/"},{"title":"VCL复习笔记","text":"明天 VCL 小测，现在要开始复习预习了。 05 反走样 Nyquist-Shannon 采样定理 为了完全避免走样的发生，我们需要让采样频率 fsf_sfs​ 至少是原信号截止频率 f0f_0f0​ 的两倍。 07 图像表示与处理 Bayesian 抠图 Poisson 抠图 08 几何表示 09 几何处理 10 几何变换 11 几何重建 12 光照和着色 反射模型 漫反射Ld=kd(Ia+Idmax⁡(0,n⋅l))L_d = k_d(I_a+I_d\\max(0,\\mathbf{n}\\cdot\\mathbf{l})) Ld​=kd​(Ia​+Id​max(0,n⋅l)) 其中 kdk_dkd​ 是表面的漫反射颜色，n\\mathbf{n}n 是表面法向，l\\mathbf{l}l 是光源的方向（从入射点指向光源），IaI_aIa​ 是环境光强度，IdI_dId​ 是光源强度（对于点光源，Id=Ipr2I_d=\\frac{I_p}{r^2}Id​=r2Ip​​）。 镜面反射Ls=ksIdmax⁡(0,n⋅h)pL_s = k_sI_d\\max(0,\\mathbf{n}\\cdot\\mathbf{h})^p Ls​=ks​Id​max(0,n⋅h)p 其中 ksk_sks​ 是表面的镜面反射颜色，n\\mathbf{n}n 是表面法向，h=normalize(l+v)\\mathbf{h}=\\text{normalize}(\\mathbf{l}+\\mathbf{v})h=normalize(l+v)（v\\mathbf{v}v 是观察者的方向），IdI_dId​ 是光源强度。 Blinn-Phong 反射模型 对于一般的物体，我们可以认为同时存在漫反射和镜面反射，从而有L=kd(Ia+Idmax⁡(0,n⋅l))+ksIdmax⁡(0,n⋅h)pL = k_d(I_a+I_d\\max(0,\\mathbf{n}\\cdot\\mathbf{l}))+k_sI_d\\max(0,\\mathbf{n}\\cdot\\mathbf{h})^p L=kd​(Ia​+Id​max(0,n⋅l))+ks​Id​max(0,n⋅h)p 13 图形管线 14 纹理映射 15 全局光照 16 高级渲染 17 物理模拟 弹簧-质点系统 两质点间的弹性势能为 Eij=12kij(∥xj−xi∥−lij)2E_{ij} = \\frac{1}{2} k_{ij} (\\left\\| \\mathbf{x}_j − \\mathbf{x}_i \\right\\| − l_{ij})^2Eij​=21​kij​(∥xj​−xi​∥−lij​)2 该弹簧的弹力为 fij=kij(∥xj−xi∥−lij)nijf_{ij} = k_{ij} (\\left\\| \\mathbf{x}_j − \\mathbf{x}_i \\right\\| − l_{ij}) \\mathbf{n}_{ij} fij​=kij​(∥xj​−xi​∥−lij​)nij​ 其中 nij\\mathbf{n}_{ij}nij​ 为从质点 iii 指向质点 jjj 方向的单位向量。 显式欧拉法 xk+1=xk+hvkvk+1=vk+hM−1f(xk)\\mathbf{x}^{k+1} = \\mathbf{x}^k + h\\mathbf{v}^k \\\\ \\mathbf{v}^{k+1} = \\mathbf{v}^k + h\\mathbf{M}^{-1}\\mathbf{f}(\\mathbf{x}^k) xk+1=xk+hvkvk+1=vk+hM−1f(xk) 隐式欧拉法 xk+1=xk+hvk+1vk+1=vk+hM−1f(xk+1)\\mathbf{x}^{k+1} = \\mathbf{x}^k + h\\mathbf{v}^{k+1} \\\\ \\mathbf{v}^{k+1} = \\mathbf{v}^k + h\\mathbf{M}^{-1}\\mathbf{f}(\\mathbf{x}^{k+1}) xk+1=xk+hvk+1vk+1=vk+hM−1f(xk+1) NS 方程 ρDvDt=−∇p+ρg+μ∇2v\\rho \\frac{\\mathrm{D}\\mathbf{v}}{\\mathrm{D}t} = -\\nabla p + \\rho \\mathbf{g} + \\mu \\nabla^2 \\mathbf{v} ρDtDv​=−∇p+ρg+μ∇2v","link":"/2025/11/24/VCL%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"关于我","text":"暂时不能给你明确的答复 我是 lowAltitudeFlyer（低空飞行），来自北京大学信息科学技术学院智班。 我喜欢跑步、骑车和美食。","link":"/2025/11/22/%E5%85%B3%E4%BA%8E%E6%88%91/"},{"title":"关于这个博客","text":"随缘更，说不定以后会写点东西呢。","link":"/2025/11/22/%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"title":"数据结构与算法MOOC答案","text":"MOOC 真是数算最勾史的部分了。 第一章 概论 点击以展开/收起答案 第二章 线性表 点击以展开/收起答案 第三章 栈与队列 点击以展开/收起答案 第四章 字符串 点击以展开/收起答案 第五章 二叉树（上） 点击以展开/收起答案 第五章 二叉树（下） 点击以展开/收起答案 第六章 树 点击以展开/收起答案 第七章 图 点击以展开/收起答案 第八章 内排序（上） 点击以展开/收起答案 第八章 内排序（下） 点击以展开/收起答案 第九章 外排序 点击以展开/收起答案","link":"/2025/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95MOOC%E7%AD%94%E6%A1%88/"},{"title":"暑期DLC记忆","text":"本篇正在施工 暑期 DLC【10&amp;15】 兰州-大河家-扎巴-雄先-倒淌河-江西沟-茶卡-刚察-多巴 在秋天的某个时刻，我惊觉这段旅程没有留下很多可供回忆的文字记录，遂开此坑。然而写了个开头就又搁置。冬游之后，原定的冬游 DLC 因感冒未能成行，短时间内也骑不了车，我又开始尝试回忆那个夏日，在记忆彻底模糊之前，将它取出，放在这里。 回忆大概一定不是完全真实的模样。以及，如果你看到比较详细的描写，可能是摘自当时的随手记录。 “唯有那日的炫目 未曾忘却” 暑期结束于兰州。 我在自述中说，有一天我一定会去骑一次环青海湖。而兰州离青海湖只有 300 余千米，机会就在眼前。刚好沧海也想在暑期后多骑一段，于是暑期 DLC 就这样诞生了。 由于我和沧海都认为我俩的体能比较好，出发前我们的路线定得相当激进：日均 150km+ 爬升 2000m+。事实上，我们还是高估了自己（尤其是恢复能力），到最后，我们没有几天是把原定路线骑完的。 Day 1 兰州-大河家镇 细雨中的清晨，最后看一眼兰州的民宿，于是转身，又上路。基调是雨的丝丝寒意。 在一家 KFC 吃了早饭，身体稍稍暖起来。我俩之前应该都没骑过这么高的强度，所以都在尽量填饱自己的肚子。沧海还在 KFC 里简单教学了心率带的使用。 真正上路的时候，还是颇为心潮澎湃的，一段新的旅程开始了。有点像暑期出发的第一天，但又有些许的不同，少了一些对长途骑行未知的好奇，多了一些挑战极限超越自我的兴奋。 我俩的行进很轻快，我能更多地感受到骑车本身带来的爽感，可以自由地释放自己的力量也不用担心超过前旗，反而若是减几脚可能就会被沧海拉开不小的一段距离。 上午雨不曾停下。出兰州市区就是一个 20km 爬升 1000m 的 HC。那个坡很清静，大运很少取道于此。那个坡也很长，坡顶很冷，两人在坡顶瑟瑟发抖，幸好找到了一家小卖部，在小卖部里用吹风机把衣服吹干，才算是活了过来。在那个坡顶我俩都有些迷茫，接下来我们还会面临什么？放坡的时候仍然很冷，只能猛猛加脚来使身体热起来。 在放坡结束后的小镇吃了午饭。我们发现进度慢于预计，于是决定不再绕去刘家峡水库南边，稍减一点强度。从午饭点出来的时候发现我扎了 雨终于停歇。下午是先爬一个比较长的坡，然后走起伏路。起伏路云雾缭绕，第一次在云间骑车，感觉很独特，不远处的树林和道路都若隐若现。 拐个弯走上一条县道，然后我们见到了非常离谱的烂路，前面的面包车都因为开不过去折返了，而我们没有其他可选的距离合适的路线，思索再三，还是决定推车过去，推完之后我的车变成了下图中的样子。 那其实根本就不是路，而是此前山体垮塌把路冲塌方了，有的车从旁边的泥里绕，压出车辙印让人以为是路罢了。此生难忘。 然后是一段烂路放坡。放坡有点惊险，我俩都把速度压的很低，毕竟风险难以承受。来令片磨损初见端倪，我俩的刹车都开始不同程度地小鸟叫，令人难绷。不过放坡的时候在山谷对面看到了丹霞地貌。 夜幕逐渐笼罩四周。两人骑行在空旷的道路上，四下无人，左手边就是黄河。此时我俩都已经挫了，不过还是我更挫一点，为了节能，沧海趴休息把在前面破风，我在后面苦苦跟随。 像看到救命稻草一般看到远处的微光，然后看着灯火渐近，终于它就在你的面前——每一个走过夜路的行者想必都有过这种体验。 终于还是在 9 点前到了——不过是又把目的地改近了一点。 大河家镇还是挺繁华的。一杯热乎的蜜安抚了我的胃和我的心。 ​Day 2 大河家镇-扎巴镇 ​Day 3 扎巴镇-雄先乡 Day 4 雄先乡-倒淌河镇 Day 5 倒淌河镇-江西沟镇 Day 6 江西沟镇-茶卡镇 Day 7 ​茶卡镇休整 Day 8 茶卡镇-刚察县 Day 9 刚察县-多巴镇 结算画面","link":"/2025/11/23/%E6%9A%91%E6%9C%9FDLC%E8%AE%B0%E5%BF%86/"}],"tags":[{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"回课","slug":"回课","link":"/tags/%E5%9B%9E%E8%AF%BE/"},{"name":"测验","slug":"测验","link":"/tags/%E6%B5%8B%E9%AA%8C/"},{"name":"qwq","slug":"qwq","link":"/tags/qwq/"},{"name":"答案","slug":"答案","link":"/tags/%E7%AD%94%E6%A1%88/"},{"name":"MOOC","slug":"MOOC","link":"/tags/MOOC/"},{"name":"长途","slug":"长途","link":"/tags/%E9%95%BF%E9%80%94/"},{"name":"夏","slug":"夏","link":"/tags/%E5%A4%8F/"},{"name":"青海湖","slug":"青海湖","link":"/tags/%E9%9D%92%E6%B5%B7%E6%B9%96/"}],"categories":[{"name":"课程","slug":"课程","link":"/categories/%E8%AF%BE%E7%A8%8B/"},{"name":"ICS","slug":"课程/ICS","link":"/categories/%E8%AF%BE%E7%A8%8B/ICS/"},{"name":"VCL","slug":"课程/VCL","link":"/categories/%E8%AF%BE%E7%A8%8B/VCL/"},{"name":"最初的最初","slug":"最初的最初","link":"/categories/%E6%9C%80%E5%88%9D%E7%9A%84%E6%9C%80%E5%88%9D/"},{"name":"DSA","slug":"课程/DSA","link":"/categories/%E8%AF%BE%E7%A8%8B/DSA/"},{"name":"骑行","slug":"骑行","link":"/categories/%E9%AA%91%E8%A1%8C/"}],"pages":[]}